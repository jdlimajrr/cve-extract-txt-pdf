import PyPDF2
import re
from collections import defaultdict
import pdfplumber

def read_txt_file(file_path):
    with open(file_path, 'r') as file:
        content = file.read()
    return content

import pdfplumber

def read_pdf_file(file_path):
    content = ''

    with pdfplumber.open(file_path) as pdf:
        total_pages = len(pdf.pages)
        for i, page in enumerate(pdf.pages):
            content += page.extract_text()
            print(f'Processed page {i + 1} of {total_pages}')

    return content


def parse_vulnerabilities(content):
    server_pattern = r'Vulnerability Details - .*? - (.*?)\n'
    vulnerability_pattern = r'Description (.*?)\n'
    solution_pattern = r'Solution (.*?)\n'
    solution_category_pattern = r'Category (Patch|Workaround)\n'
    kb_pattern = r'KB\d{7}'

    servers = re.findall(server_pattern, content)
    vulnerability_matches = re.finditer(vulnerability_pattern, content)
    solution_matches = re.finditer(solution_pattern, content)
    solution_category_matches = re.finditer(solution_category_pattern, content)
    kb_matches = re.finditer(kb_pattern, content)

    server_vulnerabilities = defaultdict(lambda: defaultdict(lambda: defaultdict(list)))
    vulnerabilities_by_kb = defaultdict(list)

    for server in servers:
        while True:
            try:
                vulnerability_match = next(vulnerability_matches)
                solution_match = next(solution_matches)
                solution_category_match = next(solution_category_matches)
                kb_match = next(kb_matches)
            except StopIteration:
                break

            vulnerability = vulnerability_match.group(1)
            solution = solution_match.group(1)
            solution_category = solution_category_match.group(1)
            kb = kb_match.group(0)

            vulnerabilities_by_kb[kb].append(vulnerability)

            server_vulnerabilities[server][solution_category][solution].append((vulnerability, kb))

            next_server_position = content.find("Vulnerability Details", vulnerability_match.end())

            if next_server_position == -1 or solution_category_match.end() < next_server_position:
                continue
            else:
                break

    return server_vulnerabilities, vulnerabilities_by_kb


def summarize_solutions(server_vulnerabilities, vulnerabilities_by_kb):
    summary = []

    for server, solution_categories in server_vulnerabilities.items():
        server_summary = f'Server: {server}\n'
        for solution_category, solutions in solution_categories.items():
            server_summary += f'  Solution Category: {solution_category}\n'
            for solution, vuln_kb_list in solutions.items():
                kbs = set(kb for vulnerability, kb in vuln_kb_list)
                for kb in kbs:
                    vulnerability_list = vulnerabilities_by_kb[kb]
                    server_summary += f'    Solution: {solution}\n'
                    server_summary += f'      KB: {kb}\n'
                    server_summary += f'      Vulnerabilities: {len(vulnerability_list)}\n'
                    for vulnerability in vulnerability_list:
                        server_summary += f'        Vulnerability: {vulnerability}\n'
        summary.append(server_summary)

    return summary



def analyze_file(file_path):
    if file_path.endswith('.txt'):
        content = read_txt_file(file_path)
    elif file_path.endswith('.pdf'):
        content = read_pdf_file(file_path)
    else:
        raise ValueError('Unsupported file format')

    server_vulnerabilities = parse_vulnerabilities(content)
    return server_vulnerabilities

def summarize_solutions(server_vulnerabilities, vulnerabilities_by_kb):
    summary = []

    for server, solution_categories in server_vulnerabilities.items():
        server_summary = f'Server: {server}\n'
        for solution_category, solutions in solution_categories.items():
            server_summary += f'  Solution Category: {solution_category}\n'
            for solution, vuln_kb_list in solutions.items():
                kbs = set(kb for vulnerability, kb in vuln_kb_list)
                for kb in kbs:
                    vulnerability_list = vulnerabilities_by_kb[kb]
                    server_summary += f'    Solution: {solution}\n'
                    server_summary += f'      KB: {kb}\n'
                    server_summary += f'      Vulnerabilities: {len(vulnerability_list)}\n'
                    for vulnerability in vulnerability_list:
                        server_summary += f'        Vulnerability: {vulnerability}\n'
        summary.append(server_summary)

    return summary

def get_all_kbs(server_vulnerabilities):
    kbs = set()

    for server, solution_categories in server_vulnerabilities.items():
        for solution_category, solutions in solution_categories.items():
            for solution, vuln_kb_list in solutions.items():
                kbs |= set(kb for vulnerability, kb in vuln_kb_list)

    return kbs

    
def format_output(result, vulnerabilities_by_kb):
    output = ''
    solutions = set()
    kbs = set()

    for server, solution_categories in result.items():
        for solution_category, solutions_dict in solution_categories.items():
            for solution in solutions_dict.keys():
                solutions.add(solution)

                for vulnerability, kb in vulnerabilities_by_kb.items():
                    if solution in vulnerability:
                        kbs.add(kb)

    kb_output = 'Lista de KBs necessárias:\n'
    for kb in kbs:
        kb_output += f'{kb}\n'

    output += kb_output
    output += '\n\n'

    for server, solution_categories in result.items():
        output += f'Server: {server}\n'
        for solution_category, solutions in solution_categories.items():
            output += f'  Solution Category: {solution_category}\n'
            for solution, vuln_kb_list in solutions.items():
                kbs = set(kb for vulnerability, kb in vuln_kb_list)
                for kb in kbs:
                    vulnerability_list = vulnerabilities_by_kb[kb]
                    output += f'    Solution: {solution}\n'
                    output += f'      KB: {kb}\n'
                    output += f'      Vulnerabilities: {len(vulnerability_list)}\n'
                    for vulnerability in vulnerability_list:
                        output += f'        Vulnerability: {vulnerability}\n'

    summary = summarize_solutions(result, vulnerabilities_by_kb)
    output += "\nResumo das soluções:\n"
    for server_summary in summary:
        output += server_summary

    return output




def save_output(output, output_file_path, kb_summary):
    with open(output_file_path, 'w') as output_file:
        output_file.write(kb_summary)
        output_file.write('\n\n')
        output_file.write(output)


def main(input_file_path, output_file_path=None):
    if not output_file_path:
        output_file_path = input_file_path.rsplit('.', 1)[0] + '_result.txt'

    try:
        result = analyze_file(input_file_path)
    except Exception as e:
        print(f'Error: {str(e)}')
        return

    if result:
        output = format_output(result)
        kbs = get_all_kbs(result)
        kb_summary = 'KBs para instalação:\n'
        for kb in kbs:
            kb_summary += f'{kb}\n'
        save_output(output, output_file_path, kb_summary)

        summary = summarize_solutions(result)
        print("\nResumo das soluções:\n")
        for server_summary in summary:
            print(server_summary)
        print(f"Resultado salvo em {output_file_path}")
    else:
        print('Erro ao analisar arquivo')

if __name__ == '__main__':
    if len(sys.argv) == 3:
        main(sys.argv[1], sys.argv[2])
    elif len(sys.argv) == 2:
        main(sys.argv[1])
    else:
        print("Uso: python vulnerability_extractor.py <input_file> [output_file]")