import PyPDF2
import re
from collections import defaultdict
import pdfplumber
import sys

def read_txt_file(file_path):
    with open(file_path, 'r') as file:
        content = file.read()
    return content

import pdfplumber

def read_pdf_file(file_path):
    content = ''

    with pdfplumber.open(file_path) as pdf:
        total_pages = len(pdf.pages)
        for i, page in enumerate(pdf.pages):
            content += page.extract_text()
            print(f'Processed page {i + 1} of {total_pages}')

    return content

def parse_vulnerabilities(content):
    server_pattern = r'Family (\w+)\n'
    vulnerability_pattern = r'Description (.*?)\n'
    solution_pattern = r'Solution (.*?)\n'
    solution_category_pattern = r'Category (Patch|Workaround)\n'
    patch_information_pattern = r'Patch Information (.*?)\n'
    kb_pattern = r'KB\d{7}'

    servers = re.findall(server_pattern, content)
    vulnerability_matches = re.finditer(vulnerability_pattern, content)
    solution_matches = re.finditer(solution_pattern, content)
    solution_category_matches = re.finditer(solution_category_pattern, content)
    patch_information_matches = re.finditer(patch_information_pattern, content)

    server_vulnerabilities = defaultdict(lambda: defaultdict(lambda: defaultdict(list)))

    for server in servers:
        while True:
            try:
                vulnerability_match = next(vulnerability_matches)
                solution_match = next(solution_matches)
                solution_category_match = next(solution_category_matches)
                patch_information_match = next(patch_information_matches)
            except StopIteration:
                break

            vulnerability = vulnerability_match.group(1)
            solution = solution_match.group(1)
            solution_category = solution_category_match.group(1)
            patch_information = patch_information_match.group(1)

            kb_matches = re.findall(kb_pattern, patch_information)

            if kb_matches:
                kbs = list(set(kb_matches))
                server_vulnerabilities[server][solution_category][solution].append((vulnerability, kbs))
            else:
                server_vulnerabilities[server][solution_category][solution].append((vulnerability, []))

            next_server_position = content.find("Description", vulnerability_match.end())

            if next_server_position == -1 or solution_category_match.end() < next_server_position:
                continue
            else:
                break

    return server_vulnerabilities

def analyze_file(file_path):
    if file_path.endswith('.txt'):
        content = read_txt_file(file_path)
    elif file_path.endswith('.pdf'):
        content = read_pdf_file(file_path)
    else:
        raise ValueError('Unsupported file format')

    server_vulnerabilities = parse_vulnerabilities(content)
    return server_vulnerabilities

def summarize_solutions(server_vulnerabilities):
    summary = "Resumo das soluções:\n\n"

    for server, categories in server_vulnerabilities.items():
        summary += f"Serviço Afetado: {server}\n"
        for category, solutions in categories.items():
            summary += f"  Solution Category: {category}\n"
            for solution, vulnerabilities in solutions.items():
                summary += f"    Solution: {solution}\n"
                summary += f"      Vulnerabilities: {len(vulnerabilities)}\n"
        summary += "\n"

    all_kbs = set()
    for server, categories in server_vulnerabilities.items():
        for category, solutions in categories.items():
            for solution, vulnerabilities in solutions.items():
                for vulnerability, kbs in vulnerabilities:
                    all_kbs.update(kbs)

    summary += "KBs encontradas:\n"
    for kb in sorted(all_kbs):
        summary += f"{kb}\n"

    return summary

def save_output(summary, output_file_path):
    with open(output_file_path, 'w') as output_file:
        output_file.write(summary)

def main(input_file_path, output_file_path=None):
    if not output_file_path:
        output_file_path = input_file_path.rsplit('.', 1)[0] + '_result.txt'

    result = analyze_file(input_file_path)
    summary = summarize_solutions(result)
    print("\nResumo das soluções:\n")
    print(summary)
    save_output(summary, output_file_path)
    print(f"Resultado salvo em {output_file_path}")

if __name__ == '__main__':
    if len(sys.argv) == 3:
        main(sys.argv[1], sys.argv[2])
    elif len(sys.argv) == 2:
        main(sys.argv[1])
    else:
        print("Uso: python vulnerability_extractor.py <input_file> [output_file]")
