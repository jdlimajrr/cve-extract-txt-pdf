import PyPDF2
import re
from collections import defaultdict
import pdfplumber
import sys

def read_txt_file(file_path):
    with open(file_path, 'r') as file:
        content = file.read()
    return content

import pdfplumber

def read_pdf_file(file_path):
    content = ''

    with pdfplumber.open(file_path) as pdf:
        total_pages = len(pdf.pages)
        for i, page in enumerate(pdf.pages):
            content += page.extract_text()
            print(f'Processed page {i + 1} of {total_pages}')

    return content

def parse_vulnerabilities(content):
    server_pattern = r'Vulnerability Details - .*? - (.*?)\n'
    vulnerability_pattern = r'Description (.*?)\n'
    solution_pattern = r'Solution (.*?)\n'
    solution_category_pattern = r'Category (Patch|Workaround)\n'
    kb_pattern = r'KB\d{7}'

    servers = re.findall(server_pattern, content)
    vulnerability_matches = re.finditer(vulnerability_pattern, content)
    solution_matches = re.finditer(solution_pattern, content)
    solution_category_matches = re.finditer(solution_category_pattern, content)

    server_vulnerabilities = defaultdict(lambda: defaultdict(lambda: defaultdict(list)))

    for server in servers:
        while True:
            try:
                vulnerability_match = next(vulnerability_matches)
                solution_match = next(solution_matches)
                solution_category_match = next(solution_category_matches)
            except StopIteration:
                break

            vulnerability = vulnerability_match.group(1)
            solution = solution_match.group(1)
            solution_category = solution_category_match.group(1)
            kb_matches = re.findall(kb_pattern, vulnerability_match.group(0))

            if kb_matches:
                kbs = list(set(kb_matches))
                server_vulnerabilities[server][solution_category][solution].append((vulnerability, kbs))
            else:
                server_vulnerabilities[server][solution_category][solution].append((vulnerability, []))

            next_server_position = content.find("Vulnerability Details", vulnerability_match.end())

            if next_server_position == -1 or solution_category_match.end() < next_server_position:
                continue
            else:
                break

    return server_vulnerabilities

def analyze_file(file_path):
    if file_path.endswith('.txt'):
        content = read_txt_file(file_path)
    elif file_path.endswith('.pdf'):
        content = read_pdf_file(file_path)
    else:
        raise ValueError('Unsupported file format')

    server_vulnerabilities = parse_vulnerabilities(content)
    return server_vulnerabilities

def summarize_solutions(server_vulnerabilities):
    summary = []

    for server, solution_categories in server_vulnerabilities.items():
        server_summary = f'Server: {server}\n'
        for solution_category, solutions in solution_categories.items():
            server_summary += f'  Solution Category: {solution_category}\n'
            for solution, vuln_list in solutions.items():
                server_summary += f'    Solution: {solution}\n'
                server_summary += f'      Vulnerabilities: {len(vuln_list)}\n'
        summary.append(server_summary)

    return summary
    
def format_output(server_vulnerabilities):
    kbs_to_vulns = defaultdict(list)

    # Agrupa as vulnerabilidades por KB
    for server, solution_categories in server_vulnerabilities.items():
        for solution_category, solutions in solution_categories.items():
            for solution, vuln_list in solutions.items():
                for vulnerability in vuln_list:
                    for kb in vulnerability[1]:
                        kbs_to_vulns[kb].append((server, solution_category, solution, vulnerability[0]))

    output = 'Vulnerabilidades agrupadas por KB:\n\n'
    for kb, vuln_list in kbs_to_vulns.items():
        output += f'KB{kb}\n'
        for server, solution_category, solution, vulnerability in vuln_list:
            output += f'  Server: {server}\n'
            output += f'  Solution Category: {solution_category}\n'
            output += f'  Solution: {solution}\n'
            output += f'  Vulnerability: {vulnerability}\n\n'

    # Formata a saída original
    output += 'Detalhamento das vulnerabilidades por servidor:\n\n'
    for server, solution_categories in server_vulnerabilities.items():
        output += f'Server: {server}\n'
        for solution_category, solutions in solution_categories.items():
            output += f'  Solution Category: {solution_category}\n'
            for solution, vuln_list in solutions.items():
                output += f'    Solution: {solution}\n'
                for vulnerability in vuln_list:
                    output += f'      Vulnerability: {vulnerability[0]}'
                    output += f' (KB{", ".join(str(kb) for kb in vulnerability[1])})\n'

    return output

def save_output(output, output_file_path):
    with open(output_file_path, 'w') as output_file:
        output_file.write(output)

def main(input_file_path, output_file_path=None):
    if not output_file_path:
        output_file_path = input_file_path.rsplit('.', 1)[0] + '_result.txt'

    result = analyze_file(input_file_path)
    output = format_output(result)
    save_output(output, output_file_path)

    summary = summarize_solutions(result)
    print("\nResumo das soluções:\n")
    for server_summary in summary:
        print(server_summary)
    print(f"Resultado salvo em {output_file_path}")


if __name__ == '__main__':
    if len(sys.argv) == 3:
        main(sys.argv[1], sys.argv[2])
    elif len(sys.argv) == 2:
        main(sys.argv[1])
    else:
        print("Uso: python vulnerability_extractor.py <input_file> [output_file]")
